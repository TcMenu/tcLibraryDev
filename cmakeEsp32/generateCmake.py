#!/usr/bin/env python3

# A script to generate CMakeLists.txt files from the TcLibrary dev libraries that are compatible with ESP-IDF
# This is an interim workaround until ESP-IDF supports CMake projects a bit more natively.

# What this does is to scan the library directory and generate CMakeLists.txt files for each library into
# the components directory of the ESP-IDF project.

# Parameters
# -l the library directory to scan and generate CMakeLists.txt files for
# -o the components directory of a project to generate LibName/CMakeLists.txt files into

import os
import sys
import glob


def collect_source_files(src_dir):
    c_files = [os.path.abspath(f) for f in glob.glob(os.path.join(src_dir, "**/*.c"), recursive=True)]
    cpp_files = [os.path.abspath(f) for f in glob.glob(os.path.join(src_dir, "**/*.cpp"), recursive=True)]
    return c_files + cpp_files


def read_library_properties(prop_file):
    dependencies = []
    with open(prop_file, 'r') as f:
        for line in f:
            if line.startswith('depends='):
                deps = line.split('=', 1)[1].strip()
                if deps:
                    dependencies.extend(d.strip() for d in deps.split(','))
    return dependencies


def process_library_dir(lib_dir, output_root):
    prop_file = os.path.join(lib_dir, "library.properties")
    src_dir = os.path.join(lib_dir, "src")

    if os.path.exists(prop_file):
        dependencies = read_library_properties(prop_file)

        print(f"Found library file: {prop_file} with {src_dir}")
        source_files = collect_source_files(src_dir)
        source_files_str = ' '.join(f'"{f}"' for f in source_files)
        output_root = os.path.abspath(output_root)
        lib_name = os.path.basename(lib_dir)
        lib_dir = os.path.join(output_root, lib_name)
        os.makedirs(lib_dir, exist_ok=True)
        output_file = os.path.join(lib_dir, f"CMakeLists.txt")
        with open(output_file, "w") as f:
            f.write("# Generated by TcLibraryDev ESP32 generator, DON'T EDIT THIS FILE\n")
            f.write(f"idf_component_register(SRCS {source_files_str}\n")
            f.write(f"                       INCLUDE_DIRS {src_dir}\n")
            requires = ["arduino-esp32"] + dependencies
            f.write(f"                       REQUIRES {' '.join(requires)})\n")


def main():
    import argparse

    parser = argparse.ArgumentParser(description='Process library files.')
    parser.add_argument('-l', '--lib', required=True, help='Library directory path')
    parser.add_argument('-o', '--output', required=True, help='Output directory path')

    args = parser.parse_args()

    if not os.path.exists(args.lib):
        print(f"Error: Library path {args.lib} does not exist")
        sys.exit(1)

    if not os.path.exists(args.output):
        print(f"Error: Output path {args.output} does not exist")
        sys.exit(1)

    for dir_name in os.listdir(args.lib):
        dir_path = os.path.join(args.lib, dir_name)
        if os.path.isdir(dir_path):
            process_library_dir(dir_path, args.output)


if __name__ == "__main__":
    main()
