/*
    The code in this file uses open source libraries provided by thecoderscorner

    DO NOT EDIT THIS FILE, IT WILL BE GENERATED EVERY TIME YOU USE THE UI DESIGNER
    INSTEAD EITHER PUT CODE IN YOUR SKETCH OR CREATE ANOTHER SOURCE FILE.

    All the variables you may need access to are marked extern in this file for easy
    use elsewhere.
 */

#include <tcMenu.h>
#include "ControlAppOledKeyboardWifi_menu.h"

// Global variable declarations
const  ConnectorLocalInfo applicationInfo = { "ControlAppOledKeyboardWifi", "1213faad-5306-4948-8ce7-db045e79babb" };

AdafruitSSD1306I2c* gfx;
AdafruitDrawable gfxDrawable;
GraphicsDeviceRenderer renderer(30, applicationInfo.name, &gfxDrawable);
MatrixKeyboardManager keyboard;
const char keyboardKeys[]  = "123456789*0#";
KeyboardLayout keyboardLayout(4, 3, keyboardKeys);
MenuEditingKeyListener tcMenuKeyListener('*', '#', 'A', 'B');

// Global Menu Item declarations
const char enumStrCars_0[] = "Ford";
const char enumStrCars_1[] = "BMW";
const char enumStrCars_2[] = "Vauxhaul";
const char enumStrCars_3[] = "Renault";
const char enumStrCars_4[] = "Mercedes";
const char enumStrCars_5[] = TC_I18N_MENU_LIST_FERRARI;
const char* const enumStrCars[]  = { enumStrCars_0, enumStrCars_1, enumStrCars_2, enumStrCars_3, enumStrCars_4, enumStrCars_5 };
const AnyMenuInfo minfoCars = { "Cars", 18, 0xffff, 0, NO_CALLBACK };
ListRuntimeMenuItem menuCars(&minfoCars, 6, enumStrCars, ListRuntimeMenuItem::FLASH_ARRAY, nullptr, INFO_LOCATION_PGM);
extern char ramChoiceData[];
const AnyMenuInfo minfoNewChoiceItem = { "Choices", 17, 0xffff, 0, NO_CALLBACK };
ScrollChoiceMenuItem menuNewChoiceItem(&minfoNewChoiceItem, 0, ramChoiceData, 10, 5, &menuCars, INFO_LOCATION_PGM);
const BooleanMenuInfo minfoBool = { "Bool", 16, 0xffff, 1, NO_CALLBACK, NAMING_YES_NO };
BooleanMenuItem menuBool(&minfoBool, false, &menuNewChoiceItem, INFO_LOCATION_PGM);
const char enumStrFoods_0[] = "Pizza";
const char enumStrFoods_1[] = "Pasta";
const char enumStrFoods_2[] = "Salad";
const char enumStrFoods_3[] = "Soup";
const char enumStrFoods_4[] = TC_I18N_MENU_ENUM_CHIPS;
const char* const enumStrFoods[]  = { enumStrFoods_0, enumStrFoods_1, enumStrFoods_2, enumStrFoods_3, enumStrFoods_4 };
const EnumMenuInfo minfoFoods = { "Foods", 15, 0xffff, 4, NO_CALLBACK, enumStrFoods };
EnumMenuItem menuFoods(&minfoFoods, 0, &menuBool, INFO_LOCATION_PGM);
const SubMenuInfo minfoChoices = { "Choices", 14, 0xffff, 0, NO_CALLBACK };
BackMenuItem menuBackChoices(&minfoChoices, &menuFoods, INFO_LOCATION_PGM);
SubMenuItem menuChoices(&minfoChoices, &menuBackChoices, nullptr, INFO_LOCATION_PGM);
const AnyMenuInfo minfoIPAddr = { "IP", 11, 0xffff, 0, NO_CALLBACK };
IpAddressMenuItem menuIPAddr(&minfoIPAddr, IpAddressStorage(127, 0, 0, 1), nullptr, INFO_LOCATION_PGM);
const AnyMenuInfo minfoPassword = { "Pwd", 10, 0xffff, 0, NO_CALLBACK };
TextMenuItem menuPassword(&minfoPassword, "", 5, &menuIPAddr, INFO_LOCATION_PGM);
const AnyMenuInfo minfoSSID = { "SSID", 9, 0xffff, 0, NO_CALLBACK };
TextMenuItem menuSSID(&minfoSSID, "", 5, &menuPassword, INFO_LOCATION_PGM);
const SubMenuInfo minfoConnectivity = { "Connectivity", 8, 0xffff, 0, NO_CALLBACK };
BackMenuItem menuBackConnectivity(&minfoConnectivity, &menuSSID, INFO_LOCATION_PGM);
SubMenuItem menuConnectivity(&minfoConnectivity, &menuBackConnectivity, &menuChoices, INFO_LOCATION_PGM);
const AnyMenuInfo minfoRGB = { "RGB", 7, 0xffff, 0, NO_CALLBACK };
Rgb32MenuItem menuRGB(&minfoRGB, RgbColor32(0, 0, 0), false, nullptr, INFO_LOCATION_PGM);
const AnyMenuInfo minfoTime = { TC_I18N_MENU_TIME_NAME, 6, 0xffff, 0, NO_CALLBACK };
TimeFormattedMenuItem menuTime(&minfoTime, TimeStorage(0, 0, 0, 0), (MultiEditWireType)3, &menuRGB, INFO_LOCATION_PGM);
const AnyMenuInfo minfoText = { TC_I18N_MENU_TEXT_NAME, 5, 0xffff, 0, NO_CALLBACK };
TextMenuItem menuText(&minfoText, "", 5, &menuTime, INFO_LOCATION_PGM);
const SubMenuInfo minfoRuntimeItems = { "Runtime Items", 4, 0xffff, 0, NO_CALLBACK };
BackMenuItem menuBackRuntimeItems(&minfoRuntimeItems, &menuText, INFO_LOCATION_PGM);
SubMenuItem menuRuntimeItems(&minfoRuntimeItems, &menuBackRuntimeItems, &menuConnectivity, INFO_LOCATION_PGM);
const BooleanMenuInfo minfoProtect = { "Protect", 21, 0xffff, 1, NO_CALLBACK, NAMING_TRUE_FALSE };
BooleanMenuItem menuProtect(&minfoProtect, false, &menuRuntimeItems, INFO_LOCATION_PGM);
const BooleanMenuInfo minfoDirect = { "Direct", 20, 0xffff, 1, NO_CALLBACK, NAMING_TRUE_FALSE };
BooleanMenuItem menuDirect(&minfoDirect, false, &menuProtect, INFO_LOCATION_PGM);
const AnyMenuInfo minfoMute = { "Mute", 19, 0xffff, 0, NO_CALLBACK };
ActionMenuItem menuMute(&minfoMute, &menuDirect, INFO_LOCATION_PGM);
const AnyMenuInfo minfoLarge = { TC_I18N_MENU_LARGE_NAME, 3, 0xffff, 0, NO_CALLBACK };
EditableLargeNumberMenuItem menuLarge(&minfoLarge, LargeFixedNumber(9, 3, 0U, 0U, false), true, &menuMute, INFO_LOCATION_PGM);
const FloatMenuInfo minfoFloat = { TC_I18N_MENU_FLOAT_NAME, 2, 0xffff, 3, NO_CALLBACK };
FloatMenuItem menuFloat(&minfoFloat, 0.0, &menuLarge, INFO_LOCATION_PGM);
const AnalogMenuInfo minfoAnalog = { TC_I18N_MENU_ANALOG_NAME, 1, 0xffff, 255, NO_CALLBACK, 0, 1, TC_I18N_MENU_ANALOG_UNIT };
AnalogMenuItem menuAnalog(&minfoAnalog, 0, &menuFloat, INFO_LOCATION_PGM);

void setupMenu() {
    // First we set up eeprom and authentication (if needed).
    setSizeBasedEEPROMStorageEnabled(true);
    // Code generated by plugins and new operators.
    gfx = new AdafruitSSD1306I2c(defaultWireTypePtr, 0xFF, 0x3C, 64, 128, ENCMODE_UTF8, SSD_1306);
    gfx->setRotation(0);
    gfx->begin();
    renderer.setUpdatesPerSecond(5);
    gfxDrawable.setGraphics(gfx);
    gfxDrawable.setFontHandler(gfx->getFontHandler());
    keyboardLayout.setRowPin(0, 22);
    keyboardLayout.setRowPin(1, 21);
    keyboardLayout.setRowPin(2, 20);
    keyboardLayout.setRowPin(3, 19);
    keyboardLayout.setColPin(0, 18);
    keyboardLayout.setColPin(1, 17);
    keyboardLayout.setColPin(2, 16);
    keyboard.initialise(internalDigitalIo(), &keyboardLayout, &tcMenuKeyListener, false);
    keyboard.setRepeatKeyMillis(850, 350);
    tcMenuKeyListener.createInternalEncoder();

    menuMgr.initWithoutInput(&renderer, &menuAnalog);
}

